<!DOCTYPE html>
<html>
  <head>
    <title>Polyglot Developer</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <textarea id="source">

      name: introduction
      class: center, middle

      # Polyglot Developer #

      ## Branching out and diversifying ##

      Alex Wynter  
      Email: awochna@email.arizona.edu  
      Github: awochna  
      Bitbucket: awochna

      --

      Learn at least one language every year.  
      .right[\- *The Pragmatic Programmer*]

      ---

      name: personal-information

      .center[# Some info about me #]

      --

      * Web Designer/Developer for Mel &amp; Enid Zuckerman College of Public Health

      ???

      * We mostly build grant, project, and center sites in Drupal for the people that need them.
      
      --

      * Favorite Programming Language: Ruby

      ???

      * It's beauty lies in it's syntax, it's object-oriented design, it's conventions, it's community, and that I feel like it really has been optimized for developer happiness.

      --

      * I do most of my work for the college in Drupal.

      ???

      * Including everything from site building to module development.

      --

      * I also do Linux server administration.

      ???

      * So between those, I do everything from helping people format their HTML properly and updating a page, to site building and design, custom module development, and managing server logs and services.

      --

      Other tools:

      .third[
      * Jekyll
      * Rails
      * drush]

      .third[
      * Apache
      * nginx
      * MySQL]

      .third[
      * Gulp
      * vim
      * git]

      ???

      * And more, of course, this is just a list of the ones I could come up with off the top of my head.

      ---

      name: agenda

      # Agenda #

      1. Purpose of this presentation

      2. How should we evaluate tools?

      3. Taking a look at some languages

      4. Taking a look at some tools

      5. Looking at a really small website project (deeper dive)

      ---

      name: purpose

      # Purpose of this presentation #

      When you need to solve a problem, you want to use the right tool, no?

      --

      We use great technologies to solve a wide variety of problems (i.e. Drupal)

      ???

      And there's a good reason for it. We'll get into that later.

      --

      However, there are some problems that our normal solutions may not be well fit for, typically edge cases, but sometimes our jobs evolve that way.

      ---

      name: purpose-cont

      # Purpose of this presentation #

      What does polyglot developer mean?

      ???

      * Generally, it refers to a developer who uses multiple languages to create software solutions, using the strengths of each.

      --

      * In this case, I'm using it to mean a developer who uses the right tool for the job, no matter what it's written in.

      --

      * Example: You may be already on this path by adopting Sass (SCSS) to help you manage your stylesheets.

      ---

      name: evaluating-tools

      # Evaluating tools #

      There are simply too many options. How do you classify them?

      ???

      * The way I've looked at tools, they can supplement functionality you're already using, or offer a replacement for a tool you are already using.
      * There are a few different types of tools we can find:

      --

      * *Supplemental tools* help you solve the problem, but aren't the solution.
      
        * Less, git, TextMate, etc.

      ???

      * Then we have replacement tools. These can be further divided into 2 more categories.

      --

      * *Drop-in replacements* are very similar to a solution you are already using.

        * Wordpress in place of Drupal, Less instead of Sass, etc.

      ???

      * These are the ones you want to avoid using. They will take time to learn and give you a marginal level of benefit.

      --

      * *Edge-case or use-case replacements* are similar to a solution you are using, but handle your particular use case better.

        * Jekyll instead of Drupal for small, static sites.

      ???

      * Reminder: We'll get to Jekyll in the case study

      ---

      name: what-to-judge

      # What to judge about them? #

      When you're evaluating a new tool, what pieces of information do you want to pay attention to?

      --

      * Maturity (Check out bug reports)

      ???

      * Project maturity is important. This should not be taken to mean how old the project is, though. Instead, check out the bug reports and go through a couple of them. If the bugs seem major, like something you could see yourself running into pretty quickly, it's not ready.

      --

      * Documentation (If you can't find them, it's a bad sign)

      ???

      * Project maturity can be forgiven to some degree given sufficient documentation. Documentation can also never be too in-depth. As you get more and more familiar with a tool, you want lower level documentation.

      --

      * Conventions/Style Guides (If they don't have one, it's also a bad sign)

      ???

      * Conventions don't have to be explicitly stated. If you need to add an arbitrary file to your project, you should be able figure out where to put it, either intuitively or because a google search should yield a result. If it's 'up to you', make sure to pick a system and stick with it, then document it.

      --

      * Tutorials and learning resources (You don't need too many, but too few hurts)

      --

      * Community and it's values (You kind of have to just jump in and find out)

      ???

      * Community can make or break your experience with a tool. An unwelcoming or dismissive community will be hard to work in when you have questions or want to contribute back to the project. I can't say I've ever seen a *bad* community, but some communities will value different things differently.

      --

      * Ecosystem

      ---

      name: languages-1

      # Lets look at some languages #

      --

      More specifically, let's evaluate:

      --

      * PHP

      * Python

      * Ruby

      * Javascript (node)

      * Go

      --

      We won't talk about the attributes previously listed, but instead, we'll discuss their strengths and weaknesses.

      ---
      
      name: php

      # PHP #

      _You can program websites, too!_

      Is known for:

      --

      * Being easy and accessible to new programmers and developers. However, language design issues are counterproductive to learners.

        * See: http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ for more info.

      ???

      * Some functions are snake_case, others camelCase. Object Oriented Programming features feel Java-like while Procedural Programming features feel C, etc.
      
      --

      * Being ubiquitous. However, some shared hosts don't update their PHP versions.
      
      --

      * Focusing strongly on solving web problems. Consequently, it's hard to use PHP for more 'general purpose' things, like command line tools.

      --

      * Developers from other languages have a hard time getting over PHP's history.

      --

      * **Good News**: Good tools built in PHP will try to alleviate and abstract these pains away from you. Except the developers from other languages.

      --

      **Note**: Facebook is written in PHP. At that scale, PHP's performance becomes a major issue, but Facebook is too big to be rewritten. As a result, they created their own PHP JIT (Just In Time) compiler, hhvm: http://hhvm.com

      ???

      So, in short, PHP is good for:

      * Web development

      * Ease of deployment

      * Non-developers

      * As a platform for other tools (Drupal, Wordpress, etc.)

      And not so good for:

      * Non-web development

      * Really complex programming problems (frameworks can help here)

      
      ---

      name: python

      # Python #

      _There should be one-- and preferably only one --obvious way to do it._

      Is known for:

      --

      * Being really easy to learn general programming with. It doesn't have a lot of the language design issues PHP suffers from.

      --

      * It's widely used in the Academic and Scientific communities. As a result, there are really good libraries for really cool things, like machine learning, hard core number crunching, etc.

      --

      * Clean syntax. Aesthetics matter!

      --

      * A huge backwards-incompatible change moving from Python 2 to Python 3.

      ???

      * Just like in Drupal when D7 came out, it took the community awhile to port or rewrite their libraries to Python 3 syntax, causing it to schism.

      --

      * It can be run on the Java Virtual Machine (JVM) via Jython: http://www.jython.org/

      ---

      name: ruby

      # Ruby #

      _Optimized for developer happiness_

      Is known for:

      --

      * Elegant and extendable syntax that makes creating a Domain Specific Language a breeze. This makes learning harder, as a result.

      --

      * Being extremely object oriented. PHP's basic types are implemented as objects in Ruby.

      --

      * Surging in popularity because of Ruby on Rails. Now that 'cooler' things have come along, some developers in other languages think it'll slowly fade away.

      --

      * The community places a high value on automated tests. This can be good or bad depending on your personal values.

      --

      * It can also run on the JVM: http://jruby.org/

      ---

      name: tools

      # Tools #

      We'll take a look at:

      --

      * Drupal

      --

      * Sass

      --

      * Selenium IDE

      --

      * Express

      --

      * Jekyll

      ---

      name: drupal-1

      # Drupal #

      * Drupal is very secure.

      ???

      * Given our position as a higher learning institute, hacks, defacement, and security breaches are particularly harsh on us in the public's view. Drupal makes security really easy.

      --

      * Drupal is flexible, extensible, and modular.

      ???

      * With the ecosystem of open-source modules, you can build almost anything you can imagine. Anything that gets too complex using contributed modules can be built in a custom module and redistributed to other sites that may need the same functionality.

      --

      * Drupal is easy to deploy.

      ???

      * Historically, developers don't often get into system administration. Drupal only requires a LAMP stack with minimal configuration. Unless you're deploying a static HTML site, it can't get much easier.

      --

      * Drupal can be used to build a simple 5 page static site for someone's grant, but it's overkill.

      ???

      * We'll take a look at an example solution later in the presentation

      --

      * Drupal can power sites with complex forms and workflows for collecting student input and graduation requirements. This can also introduce a lot of complexity that a custom app could handle better.

      ???

      We actually have a site like this at MEZCOPH.

      --

      Drupal isn't perfect for every situation though.

      --

      * Extremely complicated sites will become too hard to maintain with contributed modules alone. You'll have to build your own. Building multiple inter-dependent custom modules can start to result in many, many, many lines of code, capping development speed.

      --

      * Deployment is easy, but developing new features on a separate instance of the site and pushing them to the production instance becomes difficult and unwieldy. (They're working on fixing this, though!)

      --

      * Drupal is overkill for really small, really static sites.

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        countIncrementalSlides: false
      });
    </script>
  </body>
</html>
